%section
  %section
    :markdown
      # Excecise 03: Software Patterns

      Or **Design Patterns** for object oriented programming languages.

      Introduced by the _"Gang of four"_ in 1994.
      And updated since then.

  %section
    :markdown
      ## Design principles

      1. Progam to an **Interface** not an **Implementation**
      2. Use **Composition** before **Inheritance**
      3. **SOLID**: Single responsibility principle
      4. **KISS**: Keep it simple and stupid

%section
  %section
    :markdown
      ## The Visitor Pattern

      Construct a class that can be visited by a visitor.

  %section
    :markdown
      ### Additional Information

      - Make use of `Interface` in _Java_.

%section
  %section
    :markdown
      ## The Singleton Pattern

      Construct a class, that always has only **one** instance.

  %section
    :markdown
      ### Additional Information

      - `static` variables and methods are class methods and the same for every
          object/instance
      - Constructors can be private

%section
  %section
    :markdown
      ## The Factory Method Pattern

      The _factory method_ pattern uses a method to generate an object for a
      requester, without the requester need to know which class to instantiate.

  %section
    :markdown
      ### The Task

      _Example here is a maze game_

      Construct classes:

      1. `MazeGame` that has only `Rooms` that are direct connected
      2. `MagicMazeGame` that has also `MagicRooms` that teleport a `Runner` to a random `Room`
      3. `Room` that can have a `Challenge` or not.
      4. `MagicRoom` that teleports the `Runner` to a non `MagicRoom`
      5. `Runner` a visitor for the `Rooms`

  %section
    :markdown
      ### Additional Information

      - Class Hierarchy
      - `static`

%section
  %section
    :markdown
      ## The Decorator Pattern

      This pattern uses a class to add or overwrite functionality of an other
      class or library at runtime without an effect on other instances of the
      same class.

  %section
    :markdown
      ### The Task

      Create a class to create a coffee machine that can handle different
      coffees.

%section
  %section
    :markdown
      ## The Iterator Pattern

      Allows to decouple algorithms from containers/data structures.

      It provides a way to traverse elements of a collection, without the need,
      that the collection knows about specifics of the algorithm.

  %section
    :markdown
      ### The Task

      Create a collection in _Linked List_ variant.

      Create an _Interface_ for the iterator definition

      Make the collection to provide the _Iterator_ interface.

      Finally make an algorithm that outputs each element of the collection
      using the iterator.

%section
  %section
    :markdown
      ## The Adapter Pattern

      This pattern is able to provide an alternative interface to a class.

      - Use a class that has an incompatible interface
      - Migrate an existing not changable class to a new interface/application

      The new interface the adapter class provides can be attached on runtime to
      a class with old interface.

  %section
    :markdown
      ## The Adapter Pattern

      Utilizes data casting/conversion to make classes compatible.

  %section
    :markdown
      ### The Task

      Create an adapter to the following class to make it usable with _Strings_.

    %pre
      %code.java.hljs
        :escaped
          package eu.hsrw.ci_2_04_programming.patterns

          public class Serializer {

            public char[] getLineOf(File file) {
            }

          }

%section
  %section
    :markdown
      ## The Command Pattern

      Uses a class to aggregate

      - The method to execute
      - The parameters for the method

      and can then be handed to a class that the _Command_ is then executed
      inside.

  %section
    :markdown
      ### The Task

      - Create a _Interface_ to define the standard for a command.
      - Create a _switch on_ command
      - Create a _switch off_ command
      - Create a _change brightness_ command
      - Create a _light_ that supports the _Command_

%section
  %section
    :markdown
      ## The Chain-of-responsibility Pattern

      Uses several _Command_ objects in a chain to execute a set of operations.

      _Advantage:_ The order of commands can be composed or altered on runtime.

  %section
    :markdown
      ### The Task

      - Create a class that holds several _Command_ in a order
      - Use a the _Light_ from previous pattern
      - Build a chain of
          - Swith on
          - Dim to 80%
          - Wait 3 minutes
          - Switch off

